// Copyright 2021-2023 the Kubeapps contributors.
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file kubeappsapis/plugins/resources/v1alpha1/resources.proto (package kubeappsapis.plugins.resources.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import {
  Context,
  InstalledPackageReference,
  ResourceRef,
} from "../../../core/packages/v1alpha1/packages_pb";

/**
 * SecretType
 *
 * The type of secret. Currently Kubeapps itself only deals with OPAQUE
 * and docker config json secrets, but we define all so we can correctly
 * list the secret names with their types.
 * See https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
 *
 * @generated from enum kubeappsapis.plugins.resources.v1alpha1.SecretType
 */
export enum SecretType {
  /**
   * @generated from enum value: SECRET_TYPE_OPAQUE_UNSPECIFIED = 0;
   */
  OPAQUE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: SECRET_TYPE_SERVICE_ACCOUNT_TOKEN = 1;
   */
  SERVICE_ACCOUNT_TOKEN = 1,

  /**
   * @generated from enum value: SECRET_TYPE_DOCKER_CONFIG = 2;
   */
  DOCKER_CONFIG = 2,

  /**
   * @generated from enum value: SECRET_TYPE_DOCKER_CONFIG_JSON = 3;
   */
  DOCKER_CONFIG_JSON = 3,

  /**
   * @generated from enum value: SECRET_TYPE_BASIC_AUTH = 4;
   */
  BASIC_AUTH = 4,

  /**
   * @generated from enum value: SECRET_TYPE_SSH_AUTH = 5;
   */
  SSH_AUTH = 5,

  /**
   * @generated from enum value: SECRET_TYPE_TLS = 6;
   */
  TLS = 6,

  /**
   * @generated from enum value: SECRET_TYPE_BOOTSTRAP_TOKEN = 7;
   */
  BOOTSTRAP_TOKEN = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(SecretType)
proto3.util.setEnumType(SecretType, "kubeappsapis.plugins.resources.v1alpha1.SecretType", [
  { no: 0, name: "SECRET_TYPE_OPAQUE_UNSPECIFIED" },
  { no: 1, name: "SECRET_TYPE_SERVICE_ACCOUNT_TOKEN" },
  { no: 2, name: "SECRET_TYPE_DOCKER_CONFIG" },
  { no: 3, name: "SECRET_TYPE_DOCKER_CONFIG_JSON" },
  { no: 4, name: "SECRET_TYPE_BASIC_AUTH" },
  { no: 5, name: "SECRET_TYPE_SSH_AUTH" },
  { no: 6, name: "SECRET_TYPE_TLS" },
  { no: 7, name: "SECRET_TYPE_BOOTSTRAP_TOKEN" },
]);

/**
 * GetResourcesRequest
 *
 * Request for GetResources that specifies the resource references to get or watch.
 *
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.GetResourcesRequest
 */
export class GetResourcesRequest extends Message<GetResourcesRequest> {
  /**
   * InstalledPackageRef
   *
   * The installed package reference for which the resources are being fetched.
   *
   * @generated from field: kubeappsapis.core.packages.v1alpha1.InstalledPackageReference installed_package_ref = 1;
   */
  installedPackageRef?: InstalledPackageReference;

  /**
   * ResourceRefs
   *
   * The references to the resources that are to be fetched or watched.
   * If empty, all resources for the installed package are returned when only
   * getting the resources. It must be populated to watch resources to avoid
   * watching all resources unnecessarily.
   *
   * @generated from field: repeated kubeappsapis.core.packages.v1alpha1.ResourceRef resource_refs = 2;
   */
  resourceRefs: ResourceRef[] = [];

  /**
   * Watch
   *
   * When true, this will cause the stream to remain open with updated
   * resources being sent as events are received from the Kubernetes API
   * server.
   *
   * @generated from field: bool watch = 3;
   */
  watch = false;

  constructor(data?: PartialMessage<GetResourcesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kubeappsapis.plugins.resources.v1alpha1.GetResourcesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "installed_package_ref", kind: "message", T: InstalledPackageReference },
    { no: 2, name: "resource_refs", kind: "message", T: ResourceRef, repeated: true },
    { no: 3, name: "watch", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetResourcesRequest {
    return new GetResourcesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetResourcesRequest {
    return new GetResourcesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): GetResourcesRequest {
    return new GetResourcesRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetResourcesRequest | PlainMessage<GetResourcesRequest> | undefined,
    b: GetResourcesRequest | PlainMessage<GetResourcesRequest> | undefined,
  ): boolean {
    return proto3.util.equals(GetResourcesRequest, a, b);
  }
}

/**
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.GetResourcesResponse
 */
export class GetResourcesResponse extends Message<GetResourcesResponse> {
  /**
   * ResourceRef
   *
   * The resource reference for this single resource.
   *
   * @generated from field: kubeappsapis.core.packages.v1alpha1.ResourceRef resource_ref = 1;
   */
  resourceRef?: ResourceRef;

  /**
   * Manifest
   *
   * The current manifest of the requested resource.  Initially the JSON
   * manifest will be returned a json-encoded string, enabling the existing
   * Kubeapps UI to replace its current direct api-server getting and watching
   * of resources, but we may in the future pull out further structured
   * metadata into this message as needed.
   *
   * @generated from field: string manifest = 2;
   */
  manifest = "";

  constructor(data?: PartialMessage<GetResourcesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kubeappsapis.plugins.resources.v1alpha1.GetResourcesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource_ref", kind: "message", T: ResourceRef },
    { no: 2, name: "manifest", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetResourcesResponse {
    return new GetResourcesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetResourcesResponse {
    return new GetResourcesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): GetResourcesResponse {
    return new GetResourcesResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetResourcesResponse | PlainMessage<GetResourcesResponse> | undefined,
    b: GetResourcesResponse | PlainMessage<GetResourcesResponse> | undefined,
  ): boolean {
    return proto3.util.equals(GetResourcesResponse, a, b);
  }
}

/**
 * GetServiceAccountNamesRequest
 *
 * Request for GetServiceAccountNames
 *
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.GetServiceAccountNamesRequest
 */
export class GetServiceAccountNamesRequest extends Message<GetServiceAccountNamesRequest> {
  /**
   * Context
   *
   * The context for which the service account names are being fetched.
   *
   * @generated from field: kubeappsapis.core.packages.v1alpha1.Context context = 1;
   */
  context?: Context;

  constructor(data?: PartialMessage<GetServiceAccountNamesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName =
    "kubeappsapis.plugins.resources.v1alpha1.GetServiceAccountNamesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "context", kind: "message", T: Context },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): GetServiceAccountNamesRequest {
    return new GetServiceAccountNamesRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): GetServiceAccountNamesRequest {
    return new GetServiceAccountNamesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): GetServiceAccountNamesRequest {
    return new GetServiceAccountNamesRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetServiceAccountNamesRequest | PlainMessage<GetServiceAccountNamesRequest> | undefined,
    b: GetServiceAccountNamesRequest | PlainMessage<GetServiceAccountNamesRequest> | undefined,
  ): boolean {
    return proto3.util.equals(GetServiceAccountNamesRequest, a, b);
  }
}

/**
 * GetServiceAccountNamesResponse
 *
 * Response for GetServiceAccountNames
 *
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.GetServiceAccountNamesResponse
 */
export class GetServiceAccountNamesResponse extends Message<GetServiceAccountNamesResponse> {
  /**
   * ServiceAccountNames
   *
   * The list of Service Account names.
   *
   * @generated from field: repeated string serviceaccount_names = 1;
   */
  serviceaccountNames: string[] = [];

  constructor(data?: PartialMessage<GetServiceAccountNamesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName =
    "kubeappsapis.plugins.resources.v1alpha1.GetServiceAccountNamesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "serviceaccount_names",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): GetServiceAccountNamesResponse {
    return new GetServiceAccountNamesResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): GetServiceAccountNamesResponse {
    return new GetServiceAccountNamesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): GetServiceAccountNamesResponse {
    return new GetServiceAccountNamesResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetServiceAccountNamesResponse | PlainMessage<GetServiceAccountNamesResponse> | undefined,
    b: GetServiceAccountNamesResponse | PlainMessage<GetServiceAccountNamesResponse> | undefined,
  ): boolean {
    return proto3.util.equals(GetServiceAccountNamesResponse, a, b);
  }
}

/**
 * GetNamespaceNamesRequest
 *
 * Request for GetNamespaceNames
 *
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.GetNamespaceNamesRequest
 */
export class GetNamespaceNamesRequest extends Message<GetNamespaceNamesRequest> {
  /**
   * Cluster
   *
   * The context for which the namespace names are being fetched.  The service
   * will attempt to list namespaces across the cluster, first with the users
   * credential, then with a configured service account if available.
   *
   * @generated from field: string cluster = 1;
   */
  cluster = "";

  constructor(data?: PartialMessage<GetNamespaceNamesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kubeappsapis.plugins.resources.v1alpha1.GetNamespaceNamesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cluster", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): GetNamespaceNamesRequest {
    return new GetNamespaceNamesRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): GetNamespaceNamesRequest {
    return new GetNamespaceNamesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): GetNamespaceNamesRequest {
    return new GetNamespaceNamesRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetNamespaceNamesRequest | PlainMessage<GetNamespaceNamesRequest> | undefined,
    b: GetNamespaceNamesRequest | PlainMessage<GetNamespaceNamesRequest> | undefined,
  ): boolean {
    return proto3.util.equals(GetNamespaceNamesRequest, a, b);
  }
}

/**
 * GetNamespaceNamesResponse
 *
 * Response for GetNamespaceNames
 *
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.GetNamespaceNamesResponse
 */
export class GetNamespaceNamesResponse extends Message<GetNamespaceNamesResponse> {
  /**
   * NamespaceNames
   *
   * The list of Namespace names.
   *
   * @generated from field: repeated string namespace_names = 1;
   */
  namespaceNames: string[] = [];

  constructor(data?: PartialMessage<GetNamespaceNamesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kubeappsapis.plugins.resources.v1alpha1.GetNamespaceNamesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "namespace_names",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): GetNamespaceNamesResponse {
    return new GetNamespaceNamesResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): GetNamespaceNamesResponse {
    return new GetNamespaceNamesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): GetNamespaceNamesResponse {
    return new GetNamespaceNamesResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetNamespaceNamesResponse | PlainMessage<GetNamespaceNamesResponse> | undefined,
    b: GetNamespaceNamesResponse | PlainMessage<GetNamespaceNamesResponse> | undefined,
  ): boolean {
    return proto3.util.equals(GetNamespaceNamesResponse, a, b);
  }
}

/**
 * CreateNamespaceRequest
 *
 * Request for CreateNamespace
 *
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.CreateNamespaceRequest
 */
export class CreateNamespaceRequest extends Message<CreateNamespaceRequest> {
  /**
   * Context
   *
   * The context of the namespace being created.
   *
   * @generated from field: kubeappsapis.core.packages.v1alpha1.Context context = 1;
   */
  context?: Context;

  /**
   * Labels
   *
   * The additional labels added to the namespace at creation time
   *
   * @generated from field: map<string, string> labels = 2;
   */
  labels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<CreateNamespaceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kubeappsapis.plugins.resources.v1alpha1.CreateNamespaceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "context", kind: "message", T: Context },
    {
      no: 2,
      name: "labels",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): CreateNamespaceRequest {
    return new CreateNamespaceRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): CreateNamespaceRequest {
    return new CreateNamespaceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): CreateNamespaceRequest {
    return new CreateNamespaceRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreateNamespaceRequest | PlainMessage<CreateNamespaceRequest> | undefined,
    b: CreateNamespaceRequest | PlainMessage<CreateNamespaceRequest> | undefined,
  ): boolean {
    return proto3.util.equals(CreateNamespaceRequest, a, b);
  }
}

/**
 * CreateNamespaceResponse
 *
 * Response for CreateNamespace
 *
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.CreateNamespaceResponse
 */
export class CreateNamespaceResponse extends Message<CreateNamespaceResponse> {
  constructor(data?: PartialMessage<CreateNamespaceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kubeappsapis.plugins.resources.v1alpha1.CreateNamespaceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): CreateNamespaceResponse {
    return new CreateNamespaceResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): CreateNamespaceResponse {
    return new CreateNamespaceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): CreateNamespaceResponse {
    return new CreateNamespaceResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreateNamespaceResponse | PlainMessage<CreateNamespaceResponse> | undefined,
    b: CreateNamespaceResponse | PlainMessage<CreateNamespaceResponse> | undefined,
  ): boolean {
    return proto3.util.equals(CreateNamespaceResponse, a, b);
  }
}

/**
 * CheckNamespaceExistsRequest
 *
 * Request for CheckNamespaceExists
 *
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.CheckNamespaceExistsRequest
 */
export class CheckNamespaceExistsRequest extends Message<CheckNamespaceExistsRequest> {
  /**
   * Context
   *
   * The context of the namespace being checked for existence.
   *
   * @generated from field: kubeappsapis.core.packages.v1alpha1.Context context = 1;
   */
  context?: Context;

  constructor(data?: PartialMessage<CheckNamespaceExistsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kubeappsapis.plugins.resources.v1alpha1.CheckNamespaceExistsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "context", kind: "message", T: Context },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): CheckNamespaceExistsRequest {
    return new CheckNamespaceExistsRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): CheckNamespaceExistsRequest {
    return new CheckNamespaceExistsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): CheckNamespaceExistsRequest {
    return new CheckNamespaceExistsRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: CheckNamespaceExistsRequest | PlainMessage<CheckNamespaceExistsRequest> | undefined,
    b: CheckNamespaceExistsRequest | PlainMessage<CheckNamespaceExistsRequest> | undefined,
  ): boolean {
    return proto3.util.equals(CheckNamespaceExistsRequest, a, b);
  }
}

/**
 * CheckNamespaceExistsResponse
 *
 * Response for CheckNamespaceExists
 *
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.CheckNamespaceExistsResponse
 */
export class CheckNamespaceExistsResponse extends Message<CheckNamespaceExistsResponse> {
  /**
   * @generated from field: bool exists = 1;
   */
  exists = false;

  constructor(data?: PartialMessage<CheckNamespaceExistsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kubeappsapis.plugins.resources.v1alpha1.CheckNamespaceExistsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "exists", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): CheckNamespaceExistsResponse {
    return new CheckNamespaceExistsResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): CheckNamespaceExistsResponse {
    return new CheckNamespaceExistsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): CheckNamespaceExistsResponse {
    return new CheckNamespaceExistsResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: CheckNamespaceExistsResponse | PlainMessage<CheckNamespaceExistsResponse> | undefined,
    b: CheckNamespaceExistsResponse | PlainMessage<CheckNamespaceExistsResponse> | undefined,
  ): boolean {
    return proto3.util.equals(CheckNamespaceExistsResponse, a, b);
  }
}

/**
 * CreateSecretRequest
 *
 * Request for CreateSecret
 *
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.CreateSecretRequest
 */
export class CreateSecretRequest extends Message<CreateSecretRequest> {
  /**
   * Context
   *
   * The context of the secret being created.
   *
   * @generated from field: kubeappsapis.core.packages.v1alpha1.Context context = 1;
   */
  context?: Context;

  /**
   * Type
   *
   * The type of the secret. Valid values are defined by the Type enumeration.
   *
   * @generated from field: kubeappsapis.plugins.resources.v1alpha1.SecretType type = 2;
   */
  type = SecretType.OPAQUE_UNSPECIFIED;

  /**
   * Name
   *
   * The name of the secret.
   *
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * StringData
   *
   * The map of keys and values. Note that we use StringData here so that
   * Kubernetes handles the base64 encoding of the key values for us.
   * See https://kubernetes.io/docs/concepts/configuration/secret/#overview-of-secrets
   *
   * @generated from field: map<string, string> string_data = 4;
   */
  stringData: { [key: string]: string } = {};

  constructor(data?: PartialMessage<CreateSecretRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kubeappsapis.plugins.resources.v1alpha1.CreateSecretRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "context", kind: "message", T: Context },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(SecretType) },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 4,
      name: "string_data",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSecretRequest {
    return new CreateSecretRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSecretRequest {
    return new CreateSecretRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): CreateSecretRequest {
    return new CreateSecretRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreateSecretRequest | PlainMessage<CreateSecretRequest> | undefined,
    b: CreateSecretRequest | PlainMessage<CreateSecretRequest> | undefined,
  ): boolean {
    return proto3.util.equals(CreateSecretRequest, a, b);
  }
}

/**
 * CreateSecretResponse
 *
 * Response for CreateSecret
 *
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.CreateSecretResponse
 */
export class CreateSecretResponse extends Message<CreateSecretResponse> {
  constructor(data?: PartialMessage<CreateSecretResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kubeappsapis.plugins.resources.v1alpha1.CreateSecretResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSecretResponse {
    return new CreateSecretResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSecretResponse {
    return new CreateSecretResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): CreateSecretResponse {
    return new CreateSecretResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreateSecretResponse | PlainMessage<CreateSecretResponse> | undefined,
    b: CreateSecretResponse | PlainMessage<CreateSecretResponse> | undefined,
  ): boolean {
    return proto3.util.equals(CreateSecretResponse, a, b);
  }
}

/**
 * GetSecretNamesRequest
 *
 * Request for GetSecretNames
 *
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.GetSecretNamesRequest
 */
export class GetSecretNamesRequest extends Message<GetSecretNamesRequest> {
  /**
   * Context
   *
   * The context for which the secret names are being fetched.
   *
   * @generated from field: kubeappsapis.core.packages.v1alpha1.Context context = 1;
   */
  context?: Context;

  constructor(data?: PartialMessage<GetSecretNamesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kubeappsapis.plugins.resources.v1alpha1.GetSecretNamesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "context", kind: "message", T: Context },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): GetSecretNamesRequest {
    return new GetSecretNamesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSecretNamesRequest {
    return new GetSecretNamesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): GetSecretNamesRequest {
    return new GetSecretNamesRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetSecretNamesRequest | PlainMessage<GetSecretNamesRequest> | undefined,
    b: GetSecretNamesRequest | PlainMessage<GetSecretNamesRequest> | undefined,
  ): boolean {
    return proto3.util.equals(GetSecretNamesRequest, a, b);
  }
}

/**
 * GetSecretNamesResponse
 *
 * Response for GetSecretNames
 *
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.GetSecretNamesResponse
 */
export class GetSecretNamesResponse extends Message<GetSecretNamesResponse> {
  /**
   * SecretNames
   *
   * The list of Service Account names.
   *
   * @generated from field: map<string, kubeappsapis.plugins.resources.v1alpha1.SecretType> secret_names = 1;
   */
  secretNames: { [key: string]: SecretType } = {};

  constructor(data?: PartialMessage<GetSecretNamesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kubeappsapis.plugins.resources.v1alpha1.GetSecretNamesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "secret_names",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "enum", T: proto3.getEnumType(SecretType) },
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): GetSecretNamesResponse {
    return new GetSecretNamesResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): GetSecretNamesResponse {
    return new GetSecretNamesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): GetSecretNamesResponse {
    return new GetSecretNamesResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetSecretNamesResponse | PlainMessage<GetSecretNamesResponse> | undefined,
    b: GetSecretNamesResponse | PlainMessage<GetSecretNamesResponse> | undefined,
  ): boolean {
    return proto3.util.equals(GetSecretNamesResponse, a, b);
  }
}

/**
 * CanIRequest
 *
 * Request for CanI operation
 *
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.CanIRequest
 */
export class CanIRequest extends Message<CanIRequest> {
  /**
   * The context (cluster/namespace) for the can-i request
   * "" (empty) namespace means "all"
   *
   * @generated from field: kubeappsapis.core.packages.v1alpha1.Context context = 1;
   */
  context?: Context;

  /**
   * Group API Group of the Resource.  "*" means all.
   * +optional
   *
   * @generated from field: string group = 2;
   */
  group = "";

  /**
   * Resource is one of the existing resource types.  "*" means all.
   * +optional
   *
   * @generated from field: string resource = 3;
   */
  resource = "";

  /**
   * Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete, proxy.  "*" means all.
   * +optional
   *
   * @generated from field: string verb = 4;
   */
  verb = "";

  constructor(data?: PartialMessage<CanIRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kubeappsapis.plugins.resources.v1alpha1.CanIRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "context", kind: "message", T: Context },
    { no: 2, name: "group", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "resource", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "verb", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanIRequest {
    return new CanIRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanIRequest {
    return new CanIRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanIRequest {
    return new CanIRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: CanIRequest | PlainMessage<CanIRequest> | undefined,
    b: CanIRequest | PlainMessage<CanIRequest> | undefined,
  ): boolean {
    return proto3.util.equals(CanIRequest, a, b);
  }
}

/**
 * CanIResponse
 *
 * Response for CanI operation
 *
 * @generated from message kubeappsapis.plugins.resources.v1alpha1.CanIResponse
 */
export class CanIResponse extends Message<CanIResponse> {
  /**
   * allowed
   *
   * True if operation is allowed
   *
   * @generated from field: bool allowed = 1;
   */
  allowed = false;

  constructor(data?: PartialMessage<CanIResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "kubeappsapis.plugins.resources.v1alpha1.CanIResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allowed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanIResponse {
    return new CanIResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanIResponse {
    return new CanIResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanIResponse {
    return new CanIResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: CanIResponse | PlainMessage<CanIResponse> | undefined,
    b: CanIResponse | PlainMessage<CanIResponse> | undefined,
  ): boolean {
    return proto3.util.equals(CanIResponse, a, b);
  }
}
